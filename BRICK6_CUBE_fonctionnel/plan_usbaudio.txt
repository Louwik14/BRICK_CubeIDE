Ci-dessous, l‚Äôanalyse d√©taill√©e demand√©e (avec citations), suivie d‚Äôun plan d‚Äôaction structur√© et d‚Äôune proposition d‚Äôarchitecture cible.
‚úÖ Commandes utilis√©es

    find .. -name AGENTS.md -print

    ls BRICK6_CUBE_fonctionnel/App/Middlewares/ST/STM32_USB_Device_Library/Class

    ls BRICK6_CUBE_fonctionnel/App/Middlewares/ST/STM32_USB_Device_Library/Class/MIDI

    sed -n '1,200p' .../Class/MIDI/Inc/usbd_midi.h

    sed -n '1,240p' .../Class/MIDI/Src/usbd_midi.c

    rg -n "Descriptor|Desc" .../usbd_midi.c

    sed -n '440,560p' .../Class/CompositeBuilder/Src/usbd_composite_builder.c

    rg -n "MIDI" .../Class/CompositeBuilder

    rg -n "USE_USBD_COMPOSITE|USBD_CMPSIT" .../Class/HID

    sed -n '70,150p' .../Class/HID/Src/usbd_hid.c

    rg -n "usbd_desc.c" ...

    sed -n '1,200p' .../App/usb_stack/usbd_desc.c

1) Analyse de la classe MIDI standalone : o√π sont les descripteurs ?
‚úÖ Device descriptor (USB standard)

Le device descriptor global n‚Äôest pas dans la classe MIDI : il est d√©fini dans App/usb_stack/usbd_desc.c (table USBD_FS_DeviceDesc).
‚úÖ Device qualifier descriptor (dans la classe MIDI)

La classe MIDI d√©finit un device qualifier descriptor local (pas le device descriptor standard), dans usbd_midi.c : USBD_MIDI_DeviceQualifierDesc.
‚úÖ Configuration + Interface + Endpoint descriptors

La configuration descriptor compl√®te (incluant interface + endpoints + class-specific MIDI) est dans la classe MIDI : tableau USBD_MIDI_CfgDesc dans usbd_midi.c.

Elle comprend :

    Configuration Descriptor (bNumInterfaces = 1, etc.).

    Interface descriptor (Audio/MIDI Streaming).

    Class-specific MS interface descriptors (MS_HEADER, IN/OUT Jack).

    Endpoint descriptors (Bulk IN/OUT) + class-specific endpoint descriptors MS_GENERAL.

‚úÖ Endpoint adresses / tailles fixes dans usbd_midi.h

Les adresses et tailles sont hardcod√©es dans le header MIDI : MIDI_EPIN_ADDR, MIDI_EPOUT_ADDR, etc.
2) Ce qu‚Äôil faut retirer / modifier dans la classe MIDI pour la rendre composite-compatible

L‚Äôobjectif est de supprimer toute g√©n√©ration de descripteurs dans la classe et de ne garder que la logique (Init/DeInit/Setup/DataIn/DataOut‚Ä¶).
‚úÖ √Ä supprimer / vider / rendre inactif (dans usbd_midi.c)

√Ä retirer quand USE_USBD_COMPOSITE est actif :

    USBD_MIDI_CfgDesc (tout le tableau de descripteurs config/interface/endpoints).

    USBD_MIDI_GetCfgDesc() (retourne le buffer USBD_MIDI_CfgDesc).

    USBD_MIDI_DeviceQualifierDesc + USBD_MIDI_GetDeviceQualifierDesc() + USBD_MIDI_DeviceQualifierDescriptor() (retourne un device qualifier local).

√Ä isoler via #ifndef USE_USBD_COMPOSITE, comme dans les classes ST officielles (exemple HID) :

    Dans USBD_ClassTypeDef : en composite, les callbacks GetCfgDesc / GetDeviceQualifierDesc doivent √™tre NULL. (Mod√®le dans usbd_hid.c).

    Encapsuler toutes les d√©finitions de descripteurs MIDI sous #ifndef USE_USBD_COMPOSITE, comme le fait HID.

‚úÖ √Ä modifier (logiciel USB MIDI)

Dans USBD_MIDI_Init/DeInit/DataIn/DataOut/SendPackets, la classe utilise des endpoints fixes (MIDI_EPIN_ADDR, MIDI_EPOUT_ADDR). Cela doit √™tre remplac√© par les endpoints assign√©s par le Composite Builder, exactement comme le fait HID avec USBD_CoreGetEPAdd.
‚úÖ √Ä ajuster dans USBD_MIDI_Setup

La gestion de USB_REQ_GET_DESCRIPTOR utilise le buffer USBD_MIDI_CfgDesc + USB_MIDI_CLASS_DESC_SHIFT, donc d√©pend de la g√©n√©ration locale des descripteurs.

Dans une architecture composite propre, ce buffer doit √™tre r√©f√©renc√© depuis le descripteur composite (ou d√©sactiv√© si non requis par l‚Äôh√¥te).
üëâ C‚Äôest un point cl√© √† migrer vers le Composite Builder.
3) Analyse Composite Builder : o√π ajouter MIDI ?

Le Composite Builder a d√©j√† un case MIDI, mais il appelle une fonction non existante (USBD_MIDI_Desc).
‚úÖ Ce qui existe d√©j√† (mais incomplet)

Dans usbd_composite_builder.c :

    Allocation interface (1 interface MIDI).

    Allocation endpoints (Bulk IN + Bulk OUT).

    Appel √† USBD_MIDI_Desc(...) (√† cr√©er).

Le header composite inclut d√©j√† usbd_midi.h conditionnellement, avec l‚Äôactivation USBD_CMPSIT_ACTIVATE_MIDI.
‚úÖ O√π et comment ajouter les descripteurs MIDI

Vous devez cr√©er une fonction de g√©n√©ration MIDI dans usbd_composite_builder.c, comme :

    USBD_CMPSIT_HIDMouseDesc(...) pour HID.

    USBD_CMPSIT_MSCDesc(...) pour MSC.
    (M√™mes patterns : __USBD_CMPSIT_SET_IF + __USBD_CMPSIT_SET_EP).

üëâ Vous devez cr√©er l‚Äô√©quivalent :
static void USBD_CMPSIT_MIDIDesc(USBD_HandleTypeDef *pdev, uint32_t pConf, __IO uint32_t *Sze, uint8_t speed)
(et remplacer l‚Äôappel USBD_MIDI_Desc par USBD_CMPSIT_MIDIDesc ou impl√©menter USBD_MIDI_Desc √† c√¥t√©).
4) Plan d‚Äôaction d√©taill√© (4 √©tapes)
‚úÖ √âtape 1 ‚Äî Nettoyage de la classe MIDI (standalone ‚Üí composite)

    Isoler tout le bloc USBD_MIDI_CfgDesc et ses fonctions associ√©es (GetCfgDesc, GetDeviceQualifierDesc) sous #ifndef USE_USBD_COMPOSITE.
    (Mod√®le direct : usbd_hid.c).

    Dans USBD_ClassTypeDef, sous USE_USBD_COMPOSITE, mettre les descripteurs √† NULL (comme HID).

‚úÖ √âtape 2 ‚Äî Adapter la logique MIDI pour endpoints/interfaces dynamiques

    Remplacer MIDI_EPIN_ADDR/MIDI_EPOUT_ADDR par USBD_CoreGetEPAdd(...) dans Init, DeInit, DataIn, DataOut, SendPackets (mod√®le HID).

    Adapter la gestion du GET_DESCRIPTOR (type MIDI) pour pointer vers les descripteurs composites (ex: offset dans pConf du Composite Builder).

‚úÖ √âtape 3 ‚Äî Extension du Composite Builder (descripteurs MIDI)

    Ajouter une fonction USBD_CMPSIT_MIDIDesc dans usbd_composite_builder.c, sur le mod√®le USBD_CMPSIT_HIDMouseDesc.

    D√©placer le contenu descriptif de USBD_MIDI_CfgDesc vers cette fonction (interface + class-specific MS + endpoints).

    Remplacer USBD_MIDI_Desc(...) par USBD_CMPSIT_MIDIDesc(...) (ou impl√©menter USBD_MIDI_Desc).

‚úÖ √âtape 4 ‚Äî Int√©gration dans Composite_Audio_HID

    Activer USBD_CMPSIT_ACTIVATE_MIDI dans la config. (macro d√©j√† pr√©vue).

    V√©rifier le bNumInterfaces, la table tclasslist, et l‚Äôordre d‚Äôassemblage dans le composite.

5) Structure cible propre (proposition)
‚úÖ Descripteurs

Tous les descripteurs MIDI doivent vivre dans :
Class/CompositeBuilder/Src/usbd_composite_builder.c

    MIDI interface + jacks + endpoints g√©n√©r√©s dans USBD_CMPSIT_MIDIDesc.

    Le buffer composite devient l‚Äôunique source pour la configuration.

‚úÖ Logique MIDI

La logique USB reste dans :
Class/MIDI/Src/usbd_midi.c

    Init/DeInit/DataIn/DataOut/Setup uniquement.

    Les endpoints sont dynamiques (assign√©s par composite).

‚úÖ Communication

    Le Composite Builder alloue interfaces & endpoints ‚Üí pdev->tclasslist[].

    La classe MIDI lit ses endpoints via USBD_CoreGetEPAdd(...) (mod√®le HID).

‚úÖ R√©sum√© rapide (concret & actionnable)

Fichiers cl√©s √† modifier

    Class/MIDI/Src/usbd_midi.c

        Supprimer tout ce qui g√©n√®re des descripteurs.

        Passer en endpoints dynamiques.

    Class/MIDI/Inc/usbd_midi.h

        Garder tailles, retirer adresses fixes ou conditionner par #ifndef USE_USBD_COMPOSITE.

    Class/CompositeBuilder/Src/usbd_composite_builder.c

        Ajouter USBD_CMPSIT_MIDIDesc et g√©n√©rer les descripteurs MIDI.

Testing

    Non ex√©cut√© (analyse uniquement).

Si vous voulez, je peux maintenant :
‚úÖ proposer un patch exact fichier par fichier,
‚úÖ int√©grer le descripteur MIDI dans le Composite Builder,
‚úÖ adapter la classe MIDI en mode composite,
‚úÖ et livrer un diff complet pr√™t √† compiler